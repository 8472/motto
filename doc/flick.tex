channel semantics
  wait for input from all? one? some channels?

when to instantiate a new graph, or persist a graph?


programming
configuration
description
... are they all the same thing?

for security
performance
usability
...


properties: non-interference, liveness, time guarantees


calling a process from a different process?
  streaming data through the "subprocesses"?
creating local channels?
explicit parallel composition operator?


co-monads to express different execution contexts -- i.e., capabilities of
  different runtimes

write a back-end that emits an FSM (in dot notation). note that the space of
states can be very large, but can be cut down to manageable size if we factor it
by "similar" states. That is, if from state we can get to states 2 and 3, and
from both 2 and 3 we can get to for, and no other states are involved along
this, then we could write it as a chain "1 -> {2, 3} -> 4" if the behaviour of
states 2 and 3 satisfy some property of being "similar".






self-packet analysis
  disj across packets


* "Can you spare some change?"
  article about querying resource options before starting a job on a system.
  in our case: before starting a Flick program on a runtime.


formal model of PCAP and BPF
verified translation in both directions (compilation and decompilation)
modal-based generation and analysis of network traffic, with unprecedented flexibility
code synthesis
high assurance in ambitious extensions of both
modal logic + PCAP expressions





* How small must a little language be?

* Resource DSLs for operating and runtime systems

kinds of resource
  memory - volatile?
           content addressable?
           other? -- how to make the language extensible?
  communication - via network
                  or other IPC?
resource demands:
 - specific (range of) interfaces, IPs, 
 - as capabilities?

what kind of resources do middleboxes use?
  memory
    storage
  network
  ipc
  shims with which to communicate with other software?



* domain specific operating systems -- but feels like this is like unikernels, since they are statically specialised to carry out specific functions.


* tripos
  move parts of programs (not enhancements via middlebox) into the network

* can you use Flick to write bits of OSs?
  what would an OS for Flick look like? is it the runtime system, basically?

configuration and resource DSLs for Flick
  see Plan 9






formalise configuration





* middlebox use-case idea for Flick: transforming HTML in transit, so scripts are loaded last? or reordering the loading of assets? they way cloudflare does. how can you write cloudflare's Rocket Loader in a page?
  from http://cdata.github.io/presentations/what-else-is-cloudflare/:
    <script type="text/javascript">  â†’  <script type="text/noexec">
* middlebox use-case idea for Flick: translating a large file into a stream of smaller chunks
  inpired from http://www.quora.com/Does-CloudFlare-cache-media-files-like-*-flv-*-m4v-*-avi-*-mp4-*-mp3-files-*-mov-*-flac
* gzipping responses: https://support.cloudflare.com/hc/en-us/articles/200168086-Does-CloudFlare-gzip-resources-



* "caper" -- idea for an improved pcap expression language



using sample files to emulate, or generalise?
mutation strategy
mpeg and other formats?
PADS, erlang -- for describing protocol formats

constraint: human-generated vs tool-generated -- from static analysis?
   from source code?
- partitioning of value space?
   manual? automated? code-led?
- extracting MUST or SHOULD etc annotations from RFCs, and forming test constraints accordingly



implementation:
  crc - external vs solver-based computation
  arp - constraints over paths?
  mac addresses - constraining bits
  using to check traffic -- a la pcap, but more flexible





\documentclass{article}

\usepackage{stmaryrd}
%from http://tex.stackexchange.com/questions/24886/which-package-can-be-used-to-write-bnf-grammars
\usepackage{syntax}
%from http://tex.stackexchange.com/questions/191572/beginframed-with-background-color
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage{MnSymbol}
\usepackage{amsmath}
\usepackage{bbm}

\newcommand{\m}[1]{\ensuremath{\llbracket #1\rrbracket}}
\newenvironment{todo}{\begin{mdframed}[backgroundcolor=gray!20]\bf TODO \begin{itemize}}{\end{itemize}\end{mdframed}}
\newcommand{\q}[1]{\ensuremath{\left\ulcorner #1\right\urcorner}}

\begin{document}
\title{Flick\thanks{a part-tribute to Click}}
\author{ns441}

\maketitle

\begin{abstract}
This note specifies a subset of the Crisp language and elaborates its syntax and
semantics. Then we go on to describe how expressions in this language can be
translated into a C-like language, automatically parallelised, and then chunked
into segments that can form the bodies of Tasks in the NaaS system.
\end{abstract}

\tableofcontents

\section{Intro}
\begin{todo}
\item Get stuff from the wiki page about crisp.
\item On validating the language: having an abstract model of middlebox
  behaviour -- in SDN literature this is called the abstract forwarding model.
  Also, need to look at similar languages (there are several varieties: some
  specialised on data description, and others are slightly more general,
  oriented towards packet processing). Also, need to look at current state of
  the art for implementing the use-cases (haproxy, varnish, nginx, ...).
\item Priorities: top-down design, abstracting unwanted details (e.g., which
  version of IP, whether to use TCP...), modularity to isolate details and
  facilitate maintenance and reasoning, interfaces between the different parts,
\item 
  Deployment = Technology + Configuration\\
  Technology = Implementation + Dependencies\\
  which can be expressed as Hardware + Software.
\item
  limited expression language for serialisation annotations. also see a
  restricted
  language for preprocessor expressions for example, \#if conditions

  generate \#line and \#error in the output

  currently each tool has its own configuration language
    e.g.,
      https://www.digitalocean.com/community/tutorials/an-introduction-to-haproxy-and-load-balancing-concepts

      we could produce HAProxy and other specific configurations from our
      programs?
      and configure an entire ecosystem from a single language front-end? That
      would
      be super cool, since it would avoid reimplementing existing tools like
      HAProxy!

      how to make the language extensible for specific bits of syntax to utilise
      special hardware or software capabilities -- such as foldt.
      in OF they try to manage this extensibility as a linear order---Type 0
      switches, etc.
      This is not unlike TFF0, TFF1, etc in TPTP.
      Such an order might be too prescriptive, and therefore restrictive. So
      instead, I think people should be able to specify their own drivers in the
      compiler. They need to have distinct tokens, to avoid the situation where
      code intended for one modified compiler to be mistakenly compiled by
      another (and, in the worst scenario, yielding unexpected semantics).

      Dimensions to the language:
      - Configuration
      - Data definition language: as serialisation annotations to data types.
      Support recursive types? Support subtyping? Can support subtyping via
      refinement types?
      - Semantic extensions, and fallbacks: i.e., use TCAM if available,
      otherwise use regexes. Can use similar mechanism as for DDL?
      - Core computation language
      - Being able to reason about packets, flows, and (byte)streams
      - Cost annotations (i.e., to either statically provide measure of cost
      that is universal among all backends, or to specify how a backend is to
      measure the cost) and cut-offs (i.e., if a cost is statically higher than
      a threshold, then take a particular action at compile time; and if a cost
      cannot statically be precomputed, than if a cost of dynamically higher
      than a threshold, then take a particular action at runtime.) How are we to
      bound the cost (in terms of various and possibly heterogeneous
      resources---such as use of a particular (kind of) processor, and
      particular (kind of) network interface or channel, and particular (kind
      of) memory?
\item can we apply the idea of \emph{comprehensions} to middleboxes? i.e.,
  specifying the set of implementations of a middlebox in terms of its logical
  properties, and having the compiler give you different elements from that set,
  in the forms of implementations that can run on different backends.
\item Cool targets: C, s.t. can also compile to hardware. And, from P4, ``goal
  is to capture the general trend towards fast reconfigurable packet-processing
  pipelines'', mentioning `Forward metamorphosis' and `Intel FM6000'.
\item Integration with IDS (was it nginx that works with snort?) and things like FIDO?
  \url{http://techblog.netflix.com/2015/05/introducing-fido-automated-security.html}
\item What about using Awk to specify application-level middleboxes?
\end{todo}


\section{Flick language}
Flick consists of a subset of Crisp such that processes contain a single main block
and they don't reference other processes.
That is, processes have this form:
\begin{verbatim}
proc P : (chan1, ..., chanN, param1, ..., paramQ)
  global s1 := initvalue1
  ...
  global sP := initvalueP
  local r1 := initvalue1
  ...
  local rM := initvalueM
  Expression body
  || event1 -> expression1
     ...
  || eventL -> expressionL
\end{verbatim}
Some observations:
\begin{itemize}
  \item As before, \verb+chan1+\ldots\verb+chanN+ serve as the process' interface to the
rest of the world, including the runtime system.
\item State that is local to a process is encoded in variables
\verb+r1+\ldots\verb+rM+. Local state is used to remember values across runs of
the process.
\item State that is shared among a collection processes is encoded in variables
\verb+s1+\ldots\verb+sP+. Global state is used to remember values across runs of
all processes in the collection. In NaaS, processes are grouped by
"application", which corresponds to a tenant. Global state is initialised by the
first process that is run; subsequent processes will not reinitialise the state.
\item The process' expression body is repeatedly evaluated; the same expression is
evaluated over a possibly varying state and channel contents. The expression
body serves as the main block of a process.
\item Processes can also have an additional number of other blocks that are
  evaluated in parallel with the main block. These blocks are guarded by events,
  and their body describes how to react when their event of interest has occurred.
\item \verb+event1+\ldots\verb+eventL+ consist of Boolean-valued pure expressions.
\end{itemize}

This note details the syntax and semantics of expressions within processes.

\subsection{Syntax}
\newcommand{\syntaxcat}[1]{\ensuremath{\langle\text{\textit{#1}}\rangle}}

Here we define expressions \syntaxcat{M}, and their special subcategory
\syntaxcat{linear} consisting of simpler expressions.

In the grammar below, \syntaxcat{chan} is a category of channel identifiers,
\syntaxcat{chanArray} is a category of identifiers of channel arrays,
\syntaxcat{ref} one of references, and \syntaxcat{var} one of bound variables.
\syntaxcat{bool-exp} and \syntaxcat{arith-exp} consist of Boolean and arithmetic
expressions respectively. \syntaxcat{literal} consists of a category of
literals.

\begin{grammar}

  % FIXME I think I could merge atom and linear, and replace all occurrences of
  %       atom with occurrences of linear.
  <atom> ::= <literal>
  \alt <var>

  <linear> ::= <atom>
  \alt unity
  \alt <chan> ?
  \alt <chan> ??
  \alt <ref>
  \alt F(<atom>, $\ldots$, <atom>) % Function application.
  \alt <ref>[<linear>]
  \alt <var>[<linear>]
  \alt <chanArray>[<linear>]

  <M> ::= <linear>
  \alt <bool-exp>
  \alt <arith-exp>
  \alt if <M> then <M> else <M>
  \alt let <var> = <M> in <M>
  \alt <chan> ! <M>
  \alt <ref> := <M>
  \alt <ref>[<linear>] := <M> % Map
  \alt <M> ; <M>
  \alt fold (z : $\alpha$) (s : $\alpha \to \alpha$) <M>
  \alt section (b : $\alpha$) (f : $(\alpha \times \alpha) \to \alpha$) \\
    \qquad (<M> : ($\tau_\mathrm{idx} \to \alpha$)
      (<chanArray> : $[\tau_\mathrm{idx} \Rightarrow T_1/T_2]$))
  \alt die % kill the process, and close all channels it connects to.
  \alt close(<chan>) % close a channel.
  \alt is\_closed(<chan>) % test if a channel has been closed.
%  \alt [<chan>, $\ldots$, <chan>]  -- form array of channels.

%  <bool-exp> ::= <literal> % true or false
%  \alt <M> or <M>
%  \alt <M> and <M>
%  \alt not <M>
%  \alt <M> < <M>
%  \alt <M> = <M>
%
%  <arith-exp> ::= <literal> %0, 0.5, -4, ...
%  \alt <M>$ + $<M>
%  \alt <M>$ - $<M>
%  \alt $- $<M>
%  \alt <M>$ * $<M>
%  \alt <M>$ / $<M>
%  \alt md5(<M>)
%  %FIXME complete
\end{grammar}

Note that $c?$ blocks until it can evaluate to a value obtained from channel
$c$, removing that value from the channel. $c??$ does not block, it returns a
Boolean value indicating if a value is available for input on channel $c$.

The two channel input operations are overloaded to work on arrays of channels as
follows: if $c$ is an array of channels then $c?$ returns a list of results, one
from each channel, in sequence, and blocks until this is possible; $c??$ returns
a list of tuples, one for each channel from which an input is available. The
first element of the tuple consists of the channel's index in the channel array,
and the second element consists of the value.

fold and section allow us to compute over values that can be taken apart:
fold allows us to perform bounded recursion, while through section we can
compute over all channels in a channel array in parallel, and then
opportunistically combine their results.

Functions can have this form
\begin{verbatim}
fun F : (param1, ..., paramQ) -> (type1, ..., typeN)
  Expression body
\end{verbatim}
where the expression body is formed from a restricted syntax compared to that of
processes: functions may not interact directly with state (local, global, or
channels). That is, functions cannot store or query state, read or write or
close or check channels. Functions may not be nested either.

\begin{todo}
\item array indices should be arbitrary ordered types: string, records, etc. as
  later work could specify ordering over arbitrary types.
  Should channel arrays be annotated with this type?
  How is this type specified to section, rather than the latter assuming nat?
\item I think we should not allow aliasing between array indices -- e.g., having
  c[1] and c[192.168.2.1] mean the same channel -- since this would complicate
  things. Channels should be exclusively indexed on a single type, and that type
  need not be nat.
\item Types -- ommitted here, described in the wiki page about crisp.
\item Need associative arrays as native type, and which can be used to type
  values in local and global state too.
\item Seems handy to have address values as primitive types -- i.e., being able
  to write 192.168.2.1 directly and have it interpreted as an IPv4 address.
  (It obviously isn't a float, nor any other kind of numeral..)
  Otherwise we'd need to faff about converting between other primitive types and
  address types.
\item include functions.
\item include coercions.
\item I moved boolexp and arithexp from linear to M, so allow them to contain
  arbitrary expressions.
\item what other events to listen for? one idea is timeout.
\end{todo}

\subsection{Semantics}
\newcommand{\state}{\ensuremath{\sigma}}
\newcommand{\envir}{\ensuremath{\mathsf{v}}}
\newcommand{\channels}{\ensuremath{\mathcal{C}}}
Let \m{\cdot} denote the semantic function mapping expressions to semantic
values. This function is parametrised by
\begin{description}
  \item [state] $\state$, consists of a finite map from (local and global)
    reference identifiers to values (according to the type of the reference
    identifier).
  \item [environment] $\envir$, consists of a finite map from bound variable
    identifiers to values (according to the variable's type).
  \item [channels] $\channels$ that an expression (contained in a process) can access (to
query or modify, as the permissions may allow). Each channel $c \in \channels$
consists of a triple $\mathbbm{B} \times \vec{V} \times \vec{V}$, indicating
whether the channel is open, and the contents of the `from' and `to' directions
respectively.
\end{description}

The set $V$ is the union of all interpretations of datatypes describable in this
language. The evaluation below is defined for well-typed processes (containing
well-typed expressions).

This function maps expressions into sets of tuples, consisting of states $S$,
channels $C$, values $V$, and a boolean indication of whether the process is
still alive. Intuitively, an expression may non-deterministically
evaluate into a value, and modify the contents of the state and channels in so
doing (non-deterministically).
\[
  \m{\cdot}^{\state, \envir}_\channels : \syntaxcat{M} \to
    \mathcal{P}(\mathbbm{B} \times S \times E \times V)
\]

The evaluation of most primitives in this language is deterministic, so set
notation for the function's result will only be used in the case of
\emph{section} -- the only primitive that requires it.

Similarly, the evaluation of most primitives in this language does not bring
about the termination of the process, so this Boolean value will only be shown
for the single primitive that does -- \emph{die}.

\newcommand{\defn}{\ensuremath{\stackrel{\mathrm{def}}{=}}}

The meaning of expressions in the language is as follows:
\[
\begin{array}{lcl}
  \m{\text{x}}^{\state, \envir}_\channels &\defn{} & (\state, \channels, \envir(x))\\
  \m{\text{r}}^{\state, \envir}_\channels &\defn{} & (\state, \channels, \state(r))\\
  \m{\text{let x = M1 in M2}}^{\state, \envir}_\channels & \defn{} &
  \m{\text{M2}}^{\state', \envir'}_{\channels'} \\
  && \text{where $(\state', \channels', e) = \m{\text{M1}}^{\state,
  \envir}_{\channels}$ and $\envir' = \envir \cdot (x \mapsto e)$} \\

  \m{\text{c?}}^{\state, \envir}_\channels & \defn{} &
    (\state, \channels', e)\\
    && \text{where $\mathrm{chan}(c, \channels) = e :: es$}\\
    && \text{and \channels' =
    \channels\ except for $\mathrm{chan}(c, \channels') = es$}\\

  \m{\text{c??}}^{\state, \envir}_\channels & \defn{} &
    (\state, \channels, b)\\
    && \text{where $b = (\mathrm{chan}(c, \channels) \neq \emptyset)$}\\

  \m{\text{c ! M}}^{\state, \envir}_\channels & \defn{} &
    (\state', \channels', e)\\
    && \text{where $(\state', \channels'', e) = \m{\text{M}}^{\state, \envir}_\channels$}\\
    && \text{and \channels' =
    \channels'' except for $\mathrm{chan}(c, \channels'') = e :: \mathrm{chan}(c, \channels')$}\\

  \m{\text{if M1 then M2 else M3}}^{\state, \envir}_\channels & \defn{} &
    \text{if $e$ then $\m{\text{M2}}^{\state', \envir}_{\channels'}$ else
    $\m{\text{M3}}^{\state', \envir}_{\channels'}$}\\
    && \text{where $(\state', \channels', e) = \m{\text{M1}}^{\state, \envir}_\channels$}\\

  \m{\text{M1; M2}}^{\state, \envir}_\channels & \defn{} &
    \m{\text{M2}}^{\state', \envir}_{\channels'}\\
    && \text{where $(\state', \channels', \_) = \m{\text{M1}}^{\state, \envir}_\channels$}\\

  \m{\text{r := M}}^{\state, \envir}_\channels & \defn{} &
    (\state'', \channels', e)\\
    && \text{where $(\state', \channels', e) = \m{\text{M}}^{\state, \envir}_\channels$}\\
    && \text{and $\sigma'' = \sigma'$ except for $r$ being updated to $e$}\\

  \m{\text{fold b s M}}^{\state, \envir}_\channels & \defn{} &
    \text{if $e = 0$ then $\m{\text{b}}^{\state', \envir}_{\channels'}$ else
    $\m{\text{s $x$ (fold b s ($x - 1$))}}^{\state', \envir''}_{\channels'}$} \\
    && \text{where $(\state', \channels', e) = \m{\text{M}}^{\state, \envir}_\channels$}\\
    && \text{and $x$ is a fresh variable, and $\envir'' = \envir \cdot (x \mapsto e)$}\\

  \m{\text{section b f M chans}}^{\state, \envir}_\channels & \defn{} &
    (\state', \channels', e')\\
    && \text{where $e' = \mathtt{f}(e_1, \mathtt{f}(\ldots, \mathtt{f}(e_n, b)\ldots))$}\\
    && \text{for some permutation $e_1,\ldots,e_n$, where $n = |\mathtt{chans}|$}\\
    && \text{and $(\_, \_, e_i) = \m{\text{M}(\tau_i)}^{\state, \envir}_{\channels}$ for all $i$}\\
    && \text{and $(\state', \channels', \_) = \m{\text{M}(\tau_i)}^{\state, \envir}_{\channels}$ for some $i$}\\

  \m{\text{die}}^{\state, \envir}_\channels & \defn{} &
    (\bot, \state, \channels, \text{unity})\\

  \m{\text{close($c$)}}^{\state, \envir}_\channels & \defn{} &
    (\state, \channels', \text{unity})\\
    && \text{where \channels' = $(\channels \backslash c) \cup
      (\bot, \mathrm{from}, \mathrm{to})$}\\
    && \text{and ($\top$, from, to) = $c \in \channels$}\\

  \m{\text{is\_closed($c$)}}^{\state, \envir}_\channels & \defn{} &
      (\state, \channels, \bar{b})\\
    && \text{where (b, \_, \_) = $c \in \channels$}\\

\end{array}
\]

\begin{todo}
\item Also include: 
F(..)
r[..]
x[..]
c[..]
r[..] := M
\end{todo}


\subsection{Type checking and inference}
\begin{todo}
\item Also include explicit coercions.
\end{todo}


\subsection{Sugaring}
As with Crisp, the language can be extended with additional primitives as long
as they are derivable from the core language.
\begin{todo}
\item join, groupby, etc. See LINQ for ideas.
\end{todo}

$c?$ and $c??$ over channel arrays can be defined using `section' and
$c?$ and $c??$ over channels.
(`section' needs to provide the channel index in the array)

similarly we can lift close(\syntaxcat{chan}) and is\_closed(\syntaxcat{chan})
to arrays of channels: in the first case we close each channel, and in the
second case we can create two functions: one which returns true if at least one
channel is closed, and the other that returns true if all channels are closed.


\section{Intermediate language: IR}
This is an imperative language similar to C extended with
fork-join parallelism and queues (aka buffered channels). This collection of
features can be obtained in practice by using a combination of C and suitable
libraries. libNaaS is such a library.

\subsection{Syntax}
We have a fixed set of memory cells available, addressable by elements of
\syntaxcat{var}.
Category \syntaxcat{arr} specifies (implicitly typed) arrays,
and \syntaxcat{bool-exp} and \syntaxcat{arith-exp} specify Boolean and
arithmetical expressions respectively.
\begin{todo}
\item Fully specify the aforementioned categories.
\end{todo}

\begin{grammar}

  <expr> ::= <bool-exp>
  \alt <arith-exp>

\end{grammar}

\begin{grammar}

  <command> ::= die
  \alt <var> := <expr>
  \alt <command>; <command>
  \alt if ( <bool-exp> ) \{ <command> \} else \{ <command> \}
  \alt while ( <bool-exp> ) \{ <command> \}
  \alt for ( int <var> = <arith-exp>; <command>; <bool-exp> ) \{ <command> \}
  \alt break
  \alt continue
  \alt <arr> := fork (<fun>)
  \alt join (<arr>)

\end{grammar}

\subsection{Semantics}
\begin{todo}
\item In terms of register machine?
\end{todo}

\section{Translation from Flick to IR}
Here we define the function $\q{M}^v$ that generates an imperative program for
expression $M$ and stores the result in each of the variables in $v$. $v$
consists of a list of variables; this list may grow as we translate $M$.

We'll rely on the function $\mathrm{just}(M, v)$ which is only defined for
linear $M$, as follows: if $v = \varepsilon$ then \texttt{M}, else (it must be that $v =
v_1,\ldots,v_n$) generate the following program:
\hfill\begin{minipage}{\textwidth}
\begin{verbatim}
v1 := M;
v2 := v1;
   ...
vN := vN-1;
\end{verbatim}
\end{minipage}

\paragraph{$\q{x}^v$ \defn } $\mathrm{just}(\mathtt{x}, v)$

\paragraph{$\q{r}^v$ \defn } $\mathrm{just}(\mathtt{r}, v)$

\paragraph{$\q{c?}^v$ \defn } $\mathrm{just}(\mathtt{input(c)}, v)$

\paragraph{$\q{c??}^v$ \defn } $\mathrm{just}(\mathtt{has\_input(c)}, v)$

\paragraph{$\q{r := M}^v$ \defn } $\q{M}^{v,r}$

\paragraph{$\q{M_1; M_2}^v$ \defn }
\[\begin{array}{l}
\q{M_1}^\varepsilon; \\
\q{M_2}^v;
\end{array}\]

\paragraph{$\q{let \; x \; = \; M_1 \; in \; M_2}^v$ \defn }
\[\begin{array}{l}
\q{M_1}^x; \\
\q{M_2}^v;
\end{array}\]

\paragraph{$\q{c \; ! \; M}^v$ \defn }
let $x$ be a fresh variable, then:
\[\begin{array}{l}
    \q{M}^{x}; \\
    \mathtt{output(c, x)};
    \mathrm{just(x, v)};
\end{array}\]

\paragraph{$\q{if \; M_1 \; then \; M_2 \; else \; M_3}^v$ \defn }
let $x$ be a fresh variable, then:
\[\begin{array}{l}
\q{M_1}^x; \\
\mathtt{if (x) \{} \\
\qquad \q{M_2}^v; \\
\mathtt{\} else \{} \\
\qquad \q{M_3}^v; \\
\mathtt{\}}
\end{array}\]

\paragraph{$\q{\mathrm{fold} \; b \; s \; M}^v$ \defn }
let $\mathrm{bound}, x, \mathrm{result}$ be fresh variables; then:
\[\begin{array}{l}
\q{M}^\mathrm{bound}; \\
\text{for (int x = 0; x \textless bound; x++) \{} \\
 \qquad \text{if (x == 0) \{} \\
   \qquad\qquad \q{b}^\mathtt{result}; \\
 \qquad \text{\} else \{} \\
   \qquad\qquad \q{s(\mathrm{result})}^\mathrm{result}; \\
 \qquad \text{\}} \\
\text{\}} \\
\q{\mathrm{result}}^v; \\
\end{array}\]

\paragraph{$\q{\mathrm{section} \; b \; f \; M \; \mathrm{chans}}^v$ \defn }
let $n, i, \mathrm{children}, \mathrm{answers}, \mathrm{result}$ be fresh variables; then:
\[\begin{array}{l}
  \text{// NOTE using familiar integer indexing of arrays here.} \\
  \text{int \; n = sizeof(chans)/sizeof(chan);} \\
  \text{int[n] children;} \\
  \text{int[n] answers;} \\
  \text{for (int i = 0; i = i + 1; i \textless n) \{} \\
    \qquad \mathrm{children[i] := fork(\q{M(i)}^{answers[i]});} \\
  \text{\}} \\
  \mathtt{join(children);} \\
  \text{//Now fold over the answers.} \\
  \text{for (int i = 0; i = i + 1; i \textless n) \{} \\
    \qquad\text{if (i == 0) \{} \\
    \qquad\qquad\q{b}^\mathrm{result} \\
    \qquad\qquad\mathrm{continue;} \\
    \qquad\text{\}} \\
    \qquad \q{\mathrm{combine}(\mathtt{answers[i]},
    \mathrm{result})}^\mathrm{result}; \\
  \text{\}} \\
  \q{\mathrm{result}}^v;
\end{array}\]

\paragraph{$\q{die}^v$ := }
\hfill\begin{minipage}{\textwidth}
\begin{verbatim}
exit;
// Nothing to assign to elements of v.
\end{verbatim}
\end{minipage}

\paragraph{$\q{close(c)}^v$ := }
\hfill\begin{minipage}{\textwidth}
\begin{verbatim}
close(c);
// Nothing to assign to elements of v.
\end{verbatim}
\end{minipage}

\paragraph{$\q{is\_closed(c)}^v$ \defn } $\mathrm{just}(\mathtt{is\_closed(c)}, v)$

\begin{todo}
\item Is there still a role for dependent types? Perhaps in case number of channels is a parameter..
\item Proof of behaviour-preservation.
\end{todo}

\begin{todo}
\item Include example.
\end{todo}


\section{Transforming IR into dataflow graph}
Applied in sequence, the next two steps are intended to complete the translation
of the original Flick process into libNaaS-like components.

Note that each line in an IR program does at most one `interesting' thing; this
is intended to facilitate determining whether dataflows interfere with one
another, to infer parallelisable code segments, and to optimise the segmentation
of code with regards to resource use.

\subsection{Inferring parallelisable code segments}
We can infer parallelisable parts of expressions by ensuring that their
dataflows do not interfere with one another. We can do this by tracing back from
channel outputs, to the state and channels that contributed to the values being
sent on those channels. I propose to do this by computing the program slice for
each output step in the IR program, and then checking for disjoint slices.

Algorithm idea:
\begin{enumerate}
  \item Compute the program slice for each line containing an `output` step by
    making the list of lines that affect the values being output. At the end of
    this process we have a set of sequences line numbers -- one sequence for
    each output line.
  \item Merge elements of this set whose intersection isn't empty. Do this
    repeatedly until all of the elements are mutually disjoint.
  \item If we are left with a singleton set then we cannot parallelise the
    expression. Otherwise, each element in this set can be executed in parallel.
\end{enumerate}
Note that before running this algorithm we might want to remove dead code and
inline temporary variables, to speed up the algorithm.

\begin{todo}
\item Include example.
\end{todo}

\subsection{Segmenting into Task-like units}
Algorithm idea, to be applied to each element of the set computed by the
previous algorithm:
\begin{enumerate}
  \item For each line of the IR program (intended as an extension of pseudo C),
    we need an estimate of the cost of executing that line. For this we need a
    cost function for each instruction in the language.
  \item Apply the cost function to each line of the IR for a program.
  \item Segment the program into sequential segments such that each segment is
    of maximum cost (computed by summing instructions in that segment) without
    exceeding a threshold maximum. Do this to the extent that we can -- we might
    have to have larger segments to avoid the complexity of splitting the state,
    or -- not very different from this -- in case there are code blocks that
    cannot be split.
\end{enumerate}

\begin{todo}
\item Include example.
\end{todo}

\end{document}


types:
simply, but first-order
products -- records but with numeric labels$
  syntax: p.1
records
  syntax: r.label
common addressing/naming schemes -- such as ipv4 -- for convenience
coercions
all types are bottomed by None
  all types are implicitly option types; through analysis can remove this
you cannot send None and down a channel.

rely on record subtyping for subtyping between functions and processes

also allows us to use a process defined on layer3 in a layer 7 situation; but
not vice versa

need multiple processes


events -- open type, like exceptions
are events broadcast?


[[synthesising (de)/serialiser]]


functions can have side-effects

configuration language



